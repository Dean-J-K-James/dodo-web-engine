
<!doctype html>

<html lang="en">
    <head>
        <title>Random Walk Dungeon Generation</title>
<meta charset="utf-8">
<meta name="viewport"            content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="title"               content="Random Walk Dungeon Generation">
<meta name="image"               content="https://thecodingdodo.com/application/blog/contents/random-walk-dungeon-generation/thumbnail.png">
<meta name="description"         content="Generate random, unpredictable caves and dungeons on a 2D tilemap using the random walk algorithm.">
<meta property="og:title"        content="Random Walk Dungeon Generation">
<meta property="og:image"        content="https://thecodingdodo.com/application/blog/contents/random-walk-dungeon-generation/thumbnail.png">
<meta property="og:description"  content="Generate random, unpredictable caves and dungeons on a 2D tilemap using the random walk algorithm.">
<meta name="twitter:card"        content="summary">
<meta name="twitter:title"       content="Random Walk Dungeon Generation">
<meta name="twitter:image"       content="https://thecodingdodo.com/application/blog/contents/random-walk-dungeon-generation/thumbnail.png">
<meta name="twitter:description" content="Generate random, unpredictable caves and dungeons on a 2D tilemap using the random walk algorithm.">
<meta name="robots"              content="index, follow">
<link rel="canonical"            href="https://thecodingdodo.com/blog/random-walk-dungeon-generation">
<link rel="icon"                 href="/assets/img/favicon.png" type="image/x-icon">
<link rel="stylesheet"           href="/assets/css/main.css">
<link rel="stylesheet"           href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="https://code.jquery.com/jquery-3.6.0.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js" defer></script><script src="/assets/js/cookies.js" defer></script><script src="/assets/js/highlight.min.js" defer></script><script src="/assets/js/highlight_line_numbers.min.js" defer></script><script src="/assets/js/highlight.js" defer></script>    </head>
    <body>
        <div id="cook">
    <p>This website uses cookies for tracking. By continuing to use this website, you agree to our use of cookies. Visit our cookie policy page to learn more.</p>
    <div class="flex-fill"></div>
    <a id="cookies-accept" class="p-08 py-0">Accept</a>
</div>        <div id="menu" class="flex-row flex-08">
    <a href="/feed" class="logo">The Coding Dodo</a>
    <div class="flex-fill"></div>
    <a href="/cookies" class="p-08 py-0 ">Cookies</a><a href="/feed" class="p-08 py-0 ">Blog</a>    </div>        <div id="page" class="two-column"><div class="cell-page flex-col flex-16">
            <div class="cell flex-col flex-16 p-16 title">
<h1>Random Walk Dungeon Generation</h1>
<p class="subtitle">Last Updated: 2021-06-20</p>

    <canvas id="application-container"></canvas>
    <blockquote>
        <p><strong>Demo</strong> - Click the demo to restart the animation. Click <a href="/assets/contents/random-walk-dungeon-generation/main.js">here</a> to see the code.</p>
    </blockquote>

    
    <script type="module" src="/assets/contents/random-walk-dungeon-generation/main.js"></script>
</div>
            <div class="cell flex-col flex-16 p-16 blog"><h2>What is Random Walk?</h2>
<p>Procedural cave and dungeon generation is a fundamental aspect of many games and applications. Whether it be a 2D top-down dungeon crawler, or a 3D voxel first person shooter, procedurally generated caves and dungeons add varied, unique environments for the player to experience.</p>
<p><img src="/assets/contents/random-walk-dungeon-generation/figure1.png" alt="Example Random Walk" /></p>
<blockquote>
<p><strong>Figure 1</strong> - Example of a cave generated by the random walk algorithm.</p>
</blockquote>
<p>The random walk algorithm is a simple method that can be used to quickly create fully connected, random looking caves of varying size and shape. It works by repeatedly traversing a grid in random directions, turning cells that are passed into a path. Once the random walk is done, the results will look similar to those in <em>Figure 1</em>.</p>
<tip>The implementation and rendering of a grid is not shown in this tutorial, but many tutorials exist for creating tilemaps in various languages and engines.</tip>
<h2>Algorithm</h2>
<p>The algorithm consists of a few steps. First, the grid and variables are initialised, and then the path is generated in a loop of fixed size.</p>
<pre><code>Set all cells to a wall
Set active cell to the centre cell
Loop x times:
    Set active cell to a path
    Pick random neighbour of active cell and make it the new active cell</code></pre>
<h2>Implementation</h2>
<p>We begin by defining a function, <code>random_walk</code> , which controls the execution of the algorithm.</p>
<pre><code>random_walk() {
    this.initialise();
    for (let i = 0; i &lt; 2000; i++) {
        this.iterate_random_walk();
    }
}</code></pre>
<p>This function first calls <code>initialise</code> , which sets up the active cell coordinates, and defaults each cell in the grid to a wall. The details of this function are shown later.</p>
<p>The rest of the algorithm needs to be repeated a fixed number of times, so we are going to use a for loop that performs 2000 iterations. This example iterates 2000 times, which in my tests, produces good sized caves on a 50x50 grid. More iterations will produce larger caves, and are more suitable for larger grids. Generally, the number of iterations should be enough such that the cave spreads across the grid, but not so many that it ends up simply filling the space. Try experimenting with different numbers.</p>
<p>On each iteration, we call the <code>iterate_random_walk</code> function. This creates a path, and chooses the next active cell.</p>
<tip>The term "active" cell is simply a label we are giving to the cell that is currently being evaluated. There is nothing special or different about the cell itself.</tip>
<h2>Initialise</h2>
<p>To initialise our algorithm, we first need to setup the active cell. For this, we use <code>x</code> and <code>y</code> to represent it's position, and by default, they are initialised to the centre of the grid. The starting active cell will be the first cell in the grid to be a path; it is also the only cell guaranteed to be a path. This could be used as a player spawn point.</p>
<pre><code>initialise() {
    this.sizex = 50;
    this.sizey = 50;

    this.x = Math.floor(this.sizex / 2);
    this.y = Math.floor(this.sizey / 2);

    this.set_all_cells(this.wall);
}</code></pre>
<p>The variables, <code>sizex</code> and <code>sizey</code> represent the width and height of our grid in cells.</p>
<p>Since this algorithm is entirely random, there is no way to predict, nor are there any restrictions on, the direction the active cell will take. To get the best coverage of the grid, the centre cell is chosen as the starting active cell. This doesn't have to be the case though. To get an even more random cave system, the starting active cell could be completely random.</p>
<p>We next initialise all cells in our grid to a wall, using the function <code>set_all_cells</code> . The variables <code>wall</code> and <code>path</code> represent the state of a cell. They could be an integer, a string, or object; it all depends on how you are implementing your grid.</p>
<h2>Set All Cells</h2>
<p>The function <code>set_all_cells</code> sets all cells in the grid to the cell type that is passed. The <code>initialise</code> function passes the <code>wall</code> type. Two for-loops are used to iterate every cell.</p>
<pre><code>set_all_cells(cell_type) {
    for (let x = 0; x &lt; this.sizex; x++) {
        for (let y = 0; y &lt; this.sizey; y++) {
            this.set_cell(x, y, cell_type);
        }
    }
}</code></pre>
<p>The function <code>set_cell</code> sets the cell located at <code>x</code> , <code>y</code> , to the passed cell type. It isn't impemented in this tutorial, and is dependant on how you handle tilemaps.</p>
<h2>Iterate Random Walk</h2>
<p>The <code>iterate_random_walk</code> function gets repeatedly called by <code>random_walk</code> . On each call, a single cell gets set to a path, and the active cell's position gets updated.</p>
<p>First thing is to set the active cell to a path using the <code>set_cell</code> function.</p>
<pre><code>iterate_random_walk() {
    this.set_cell(this.x, this.y, this.path);

    switch (Math.floor(Math.random() * 4)) {
        case 0: this.y--; break;
        case 1: this.x++; break;
        case 2: this.y++; break;
        case 3: this.x--; break;
    }

    this.x = Math.max(1, Math.min(this.x, this.sizex - 2));
    this.y = Math.max(1, Math.min(this.y, this.sizey - 2));
}</code></pre>
<p>Remember that the <code>x</code> and <code>y</code> variables represent the active cell. Now that it has been set to a path, the active cell needs to change. As required in the algorithm, the next active cell must be a random neighbour of the current active cell. A switch statement based on a randomly generated number between 0 and 3 increments/ decrements the relevant axis. Each of the 4 directions corresponds to one of north, east, south or west.</p>
<p>Once the switch has been run, one of the <code>x</code> and <code>y</code> coordinates of the active cell will have changed. Because the direction is random, it is possible that the new active cell is already a path. This is fine, though, as it keeps the cave size random.</p>
<p>Our grid is finite, with a fixed width and height. As the active cell is traversing the grid on each iteration, we need to validate it is within the bounds of the grid. This is done by clamping the coordinates using the <code>min</code> and <code>max</code> functions. Most languages will have these functions readily available.</p>
<h2>Keeping the Cave Random</h2>
<p>Throughout each call of the <code>iterate_random_walk</code> function, the data is never quality tested. The only validation is clamping the coordinates so that our array indexes dont overflow. This lack of quality assurance can result in two things:</p>
<ul>
<li>The next active cell is already a path. This is desirable because it keeps the size of the cave random and unpredictable.</li>
<li>If the active cell is already at the edge of the grid, there is a 25% chance of the next coordinate being clamped and therefore not changing. This can cause the undesirable effect of having our path "stick" to an edge, like in <em>Figure 2</em>. To fix this, we could make sure to choose only valid directions in the switch statement.</li>
</ul>
<p><img src="/assets/contents/random-walk-dungeon-generation/figure2.png" alt="Cave Sticking to Edge of Grid" /></p>
<blockquote>
<p><strong>Figure 2</strong> - Example of a cave sticking to the edge of a grid.</p>
</blockquote>
<p>The random walk algorithm is a very simple and easy technique to use. In reality, the caves it generates are not necessarily perfect for an actual game, because it's heavy reliance on random numbers can result in wierd looking worlds.</p>
<p>Personally, when I am making games that need to generate caves and dungeons, the random walk algorithm is the first one I implement, but for testing rather than an actual game feature.</p>
<h2>Further Reading</h2>
<ul>
<li>The RogueBasin wiki has a page on <a href="http://www.roguebasin.com/index.php?title=Random_Walk_Cave_Generation">Random Walk Cave Generation</a>, which demonstrates similar ideas to this article.</li>
<li>Mozilla web docs have a page describing <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/Tilemaps">Tilemaps</a>, for web development. Some of the concepts can be transferred to tilemaps in non-web environments.</li>
</ul></div>
            <div class="cell flex-col flex-16 p-16 feedback"><h2>Questions or Feedback?</h2>
<p>Thank you for reading this article!</p>
<p>If you have any further questions or queries, then don't hesitate to contact me on Twitter or by Email.</p></div>
    </div>

<div class="cell-side flex-col flex-16">
            <div class="cell flex-col flex-04 p-16 articles"><a href="/blog/depth-first-search-maze" class="card flex-col flex-04 p-08 "><p class="title">Depth First Search Maze</p><p class="subtitle">2021-06-27</p></a><a href="/blog/game-of-life" class="card flex-col flex-04 p-08 "><p class="title">Conway's Game of Life</p><p class="subtitle">2021-09-18</p></a><a href="/blog/perlin-noise-terrain-generation" class="card flex-col flex-04 p-08 "><p class="title">Perlin Noise Terrain Generation</p><p class="subtitle">2021-07-04</p></a><a href="/blog/random-walk-dungeon-generation" class="card flex-col flex-04 p-08 active"><p class="title">Random Walk Dungeon Generation</p><p class="subtitle">2021-06-20</p></a></div>
    </div></div>        <div id="foot"><a href="https://twitter.com/thecodingdodo" class="fa fa-twitter"></a>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="https://www.youtube.com/channel/UCLYv_FM6EbtTbfJpFuEzPbQ" class="fa fa-youtube"></a>
&nbsp;&nbsp;&nbsp;&nbsp;
<a href="mailto:dean.j.k.james@gmail.com" class="fa fa-envelope"></a></div>    </body>
</html>

